=====================================================
[EDP] Using trust delegation for Swift authentication
=====================================================


https://blueprints.launchpad.net/sahara/+spec/edp-swift-trust-authentication


Sahara currently stores and distributes credentials for access to Swift
objects. These credentials are username/password pairs that are stored in
Sahara's database. This blueprint describes a method for using Keystone’s
trust delegation mechanism to remove the storage of credentials from Sahara's
purview.

Problem description
===================

Sahara allows access to job binaries and data sources stored in Swift
containers by storing credentials to those containers. The credentials are
stored in Sahara’s database and distributed to cluster instances as part of a
job’s workflow, or used by Sahara to access job binaries. The storage of
credentials in Sahara's database represents a security risk that can be
avoided.

Proposed change
===============

A solution to using credentials for access to Swift objects is to generate a
Keystone trust between the user with access to those objects and a Sahara
proxy user. The trust would be established based on the user’s membership in
the project that contains the Swift objects. Using this trust the Sahara proxy
user could generate authentication tokens to access the Swift objects. When
access is no longer needed the trust can be revoked thus invalidating the
tokens.

The proxy user will default to the Sahara admin user. A configuration option
will allow the end user to specify an alternate proxy user, thus allowing for
an extra layer of segregation for the trust delegation.

With this methodology Sahara could move away from storing username/password
credentials for Swift access and instead only store a trust identifier.

*A note about Keystone and users*
An improvement over this design would be for Sahara to create a temporary
user associated with each job to provide even greater segregation of access
privileges. The major blocker to this is that if Keystone uses an external
identity store(e.g. LDAP), Sahara may not have sufficient privileges to
create the temporary user.

General breakdown of the process:

1. When a new job that involves Swift objects is created, a trust for the
   context user’s role is delegated from the context user to the Sahara proxy
   user.

2. A periodic update is maintained that will acquire a token associated with
   the delegated trust. The periodic update will place the token value into a
   file-based key/value store on every node in the cluster. The update will
   keep the tokens refreshed based on Keystone's timeout for each token.

3. When an instance needs to access a Swift object it uses the token in it’s
   local file-based key/value store to access that object.

4. When a job has ended, the delegated trust will be revoked from the Sahara
   proxy user, the stored token on all cluster instances will be removed, and
   the periodic update associated with the job will be cleared.

Detailed breakdown:

Step 1.

Whenever a new job is issued through Sahara a new trust is generated by
requesting it from Keystone using the access credentials of the context user.
The “context user” is defined as the user who is currently logged in to
OpenStack. The trust will be based on the context user’s “Member” role in
the project that is associated with the Swift objects.

The generated trust will be consumed by the Sahara proxy user. This user will
be configurable by value in sahara.conf and will default to the Sahara admin
user.

Because Sahara does not know how long a job will run the trust will need to be
established with no expiration date and unlimited reuses. The trust will also
need to be established with impersonation to allow for cases where output
needs to be written. By using impersonation we will ensure that created files
will be owned by the context user.

When a job is created, the unique identifier associated with it will be
recorded in the workflow.xml that is passed to the cluster instances. In this
respect the job identifier will be used as the primary means of coordinating
authentication tokens from the instances.

Sahara will also need to distribute the Swift storageURL to each instance that
requires access. This can be supplied in the workflow.xml using the current
"swift://" URL scheme.

Step 2.

For each job started, Sahara will need to maintain a periodic update
responsible for acquiring and distributing trust based authentication tokens.
Keystone defines the length of time that each token is valid for, and because
of this Sahara will need to keep the tokens refreshed.

On the cluster instances the tokens should be stored and associated with a
unique identifier for their job. This would take the form of a file stored in
a Sahara specific directory for the cloud user on each instance requiring
access. The files would be named as their job identifier and store only their
trust based token.

Step 3.

During job execution when an instance needs access to a Swift object, the
Swift file system connector will take the unique job identifier from the
workflow and open the file with the same name. From the file a Keystone token
will be extracted and used as the method of authentication to the Swift
object.

The token will be cached by the Swift file system connector and used until
Swift returns a failed connection based on authentication. When this happens,
the token will be reread and cached from the local file.

Step 4.

After a job has completed Sahara will revoke the trust from Keystone using an
authentication token based on the trust. Additionally the periodic update
associated with the job will be removed and the token files from each instance
will be destroyed.

Alternatives
------------

Two alternatives have been discussed regarding this issue; using Swift’s
TempURL mechanism, and encrypting the Swift credentials.

Swift implements a feature named TempURL which allows the generation of
temporary URLs to allow public access to Swift objects. Using this feature
Sahara could create TempURLs for each Swift object that requires access and
then distribute these URLs to the cluster instances in the job workflow.

Although TempURLs would be low impact in terms of the work required to
implement they have a few major drawbacks for Sahara’s use case. When
creating a TempURL an expiration date must be associated with the URL. As
job lengths in Sahara cannot be predictively determined this would mean
creating indefinite expiration dates for the TempURLs. A solution to this
would be deleting the Swift object or changing the authentication identifier
associated with the creation of the TempURL. Both of these options present
implications that run beyond the boundaries of Sahara. In addition the
TempURLs would need to be passed to the instances as ciphertext to avoid
potential security breaches.

The other methodology discussed involves encrypting the Swift credentials and
allowing the cluster instances to decrypt them when access is required. Using
this method would involve Sahara generating a two part public/private key that
would be used to encrypt all credentials. The decryption, or private, part of
the key would be distributed to all cluster nodes. Upon job creation the Swift
credentials associated with the job would be encrypted and stored. The
encrypted credentials would be distributed to the cluster instances in the job
workflow. When access is needed to a Swift object, an instance would decrypt
the credentials using the locally stored key.

Encrypting the credentials poses a lower amount of change over using Keystone
trusts but perpetuates the current ideology of Sahara storing credentials for
Swift objects. In addition a new layer of security management becomes involved
in the form of Sahara needing to generate and store keys for use with the
credentials. This complexity adds another layer of management that could
instead be relegated to a more appropriate OpenStack service(i.e. Keystone).

Data model impact
-----------------

The data model would need to be changed to remove the username and password
associated with Swift objects for each data source and job. The impact for
databases that were unable to migrate these changes would be limited as the
fields would no longer be used.

The job execution model will need to have a field for the trust identifier
added. This should not impact users who are upgrading, but care must be
take to advise that no database upgrade should be performed while job
executions have been started.

REST API impact
---------------

None

Other end user impact
---------------------

Users will no longer need to enter credentials when adding Swift data sources
to their jobs.

The user’s OpenStack credentials will need to have sufficient privileges to
access the Swift objects they add.

From the python-saharaclient, developers will no longer need to enter
credential_user or credential_pass when making a requests to create data
sources.

The end user will now have the option to create a Sahara proxy user. This
will not be required, but is provided as an option for stack administrators
who wish a greater level of segregation for the trust delegation.

Deployer impact
---------------

A deployer will need to be aware of the proxy user configuration, but as this
will be optional it does not have a major impact on deployment.

Developer impact
----------------

Developers will no longer need to pass credentials when creating data sources.

Sahara-image-elements impact
----------------------------

None

Sahara-dashboard / Horizon impact
---------------------------------

The username and password fields will need to be removed from the Swift data
source forms and views.

Implementation
==============

Assignee(s)
-----------

Primary assignee:


Other contributors:


Work Items
----------

* Trust acquisition per job
* Periodic token updater
* Token distribution to instances
* Swift file system component update to use tokens
* Trust revocation and token destruction

Dependencies
============

This feature will require the usage of Keystone v3 with the OS-TRUST mechanism
enabled.

There will also be a dependency on the Horizon
change(removing username/password), which will ultimately depend on the
Sahara dashboard merges.

The Hadoop Swift file system component will need to be updated as well.

Testing
=======

The current tests for Swift based objects will need to be modified to remove
the usage of username/password credentials. Otherwise these tests should prove
that the trust method is working properly.

Tests for situations where a user’s Keystone access do not permit permission
for the Swift objects they are adding should be implemented.

Tests should also be generated for conditions where a token expiration occurs
during operation to ensure that the instances will properly recover and wait
for a token update or fail.

The token distribution methods will need testing to ensure that a failed token
update can be handled.

The Swift file system component will need it’s tests modified for the token
key/value store, as well as access to the Swift objects. These tests should
include token expiration as well as general work flow.

Documentation Impact
====================

The documentation for usage of Swift storage will need to have references to
the object credentials removed. Additionally there should be documentation
added about the impact of a user not having access to the Swift sources.

References
==========

Original bug report
https://bugs.launchpad.net/sahara/+bug/1321906


Keystone trust API reference
https://github.com/openstack/identity-api/blob/master/v3/src/markdown/identity-api-v3-os-trust-ext.md

